@startuml
!theme plain
skinparam backgroundColor #FEFEFE
skinparam sequenceMessageAlign center
skinparam handwritten false

title Diagrama de Secuencia - Detección de Mutantes\nExamen MercadoLibre Backend Developer

actor Cliente as client
participant "MutantController" as controller
participant "MutantService" as service
participant "MutantDetector" as detector
participant "DnaRecordRepository\n(Singleton JPA)" as repo
database "H2 Database" as db

== Caso 1: ADN Nuevo (No existe en caché) ==

client -> controller: POST /mutant\n{"dna": ["ATGCGA",...]}
activate controller

controller -> controller: @Validated\nvalidar DnaRequest
note right
  Validaciones Bean Validation:
  - @NotNull, @NotEmpty
  - @ValidDnaSequence
end note

controller -> service: analyzeDna(dna[])
activate service

service -> service: calculateDnaHash(dna)\nSHA-256
note right
  Hash calculado:
  "3a5f2c9e8b1d..."
end note

service -> repo: findByDnaHash(hash)
activate repo
repo -> db: SELECT * FROM dna_records\nWHERE dna_hash = ?
activate db
db --> repo: Optional.empty()
deactivate db
repo --> service: Optional.empty()
deactivate repo

note over service
  No existe en BD
  → Analizar DNA
end note

service -> detector: isMutant(dna[])
activate detector

detector -> detector: isValidDna(dna)
note right
  Validaciones:
  - No null/empty
  - Matriz NxN
  - Solo A,T,C,G
end note

detector -> detector: char[][] matrix =\ntoCharArray()
note right
  Optimización:
  Conversión para
  acceso O(1)
end note

loop Single Pass - Recorrer matriz UNA vez
  detector -> detector: checkHorizontal(row, col)
  detector -> detector: checkVertical(row, col)
  detector -> detector: checkDiagonalDescending(row, col)
  detector -> detector: checkDiagonalAscending(row, col)

  alt sequenceCount > 1
    note over detector
      Early Termination
      ¡Para aquí!
    end note
    detector --> service: return true
  end
end

detector --> service: true (es mutante)
deactivate detector

service -> service: new DnaRecord(\nhash, isMutant=true)

service -> repo: save(dnaRecord)
activate repo
repo -> db: INSERT INTO dna_records\n(dna_hash, is_mutant, created_at)\nVALUES (?, ?, ?)
activate db
db --> repo: DnaRecord guardado
deactivate db
repo --> service: DnaRecord
deactivate repo

service --> controller: true
deactivate service

controller --> client: 200 OK
deactivate controller

== Caso 2: ADN Cacheado (Ya existe en BD) ==

client -> controller: POST /mutant\n{"dna": ["ATGCGA",...]}
activate controller

controller -> service: analyzeDna(dna[])
activate service

service -> service: calculateDnaHash(dna)

service -> repo: findByDnaHash(hash)
activate repo
repo -> db: SELECT * FROM dna_records\nWHERE dna_hash = ?
activate db
db --> repo: DnaRecord encontrado
deactivate db
repo --> service: Optional.of(record)
deactivate repo

note over service
  ✅ Existe en BD (caché)
  → Retornar resultado guardado
  → NO llamar a detector
  → Ahorro de procesamiento
end note

service --> controller: record.isMutant()
deactivate service

controller --> client: 200 OK / 403 Forbidden
deactivate controller

== Caso 3: Obtener Estadísticas ==

client -> controller: GET /stats
activate controller

controller -> service: getStats()
activate service

service -> repo: countByIsMutant(true)
activate repo
repo -> db: SELECT COUNT(*)\nFROM dna_records\nWHERE is_mutant = true
activate db
db --> repo: 40
deactivate db
repo --> service: 40
deactivate repo

service -> repo: countByIsMutant(false)
activate repo
repo -> db: SELECT COUNT(*)\nFROM dna_records\nWHERE is_mutant = false
activate db
db --> repo: 100
deactivate db
repo --> service: 100
deactivate repo

service -> service: calculateRatio(40, 100)
note right
  ratio = 40 / 100 = 0.4
end note

service --> controller: StatsResponse\n(40, 100, 0.4)
deactivate service

controller --> client: 200 OK\n{"count_mutant_dna": 40,\n"count_human_dna": 100,\n"ratio": 0.4}
deactivate controller

@enduml